# -*- coding: utf-8 -*-
"""
Created on Tue Aug 31 11:30:39 2021

@author: cherw
"""


'''
ID: REVC
Q: Complementing a Strand of DNA
In DNA strings, symbols 'A' and 'T' are complements of each other, as are 'C' and 'G'.

The reverse complement of a DNA string s is the string sc formed by reversing the symbols of s, then taking the complement of each symbol (e.g., the reverse complement of "GTCA" is "TGAC").

Given: A DNA string s of length at most 1000 bp.

Return: The reverse complement sc of s.
'''

test1 = "AAAACCCGGT"
test2 = "ACTGGAACGTTTGTGGTTAGCAGCGCCCACAGACAGTGGACTTCTGCGGAAGTAAGTCGCAATAGTAACCCACTGGTCAAACATTTACGTACAGCGCATCGGAGAAGGAACGGTCCACAGCTTGACTCACCCAACATCGTCAGCATAAAAGGAACAAACTGACATAGCGGAGCTTCACTAGAACTGGACTTGTAAAAAGCCGCCGAAAAACTGCACCAAGATAGGACTATAATGACCCAACCTATTACCCTCGCCGCTGTCCACGAATGGGCAGGACTGGACTAATCAGTATGGGGCACTGGCGGTATTCGGCGATAGATCAGTGTCTCAGGCCGACGAGAGCACGTCCCCAAATCAAGTCCAAACGATACACAGATTAAGACTGACTTGTGCACGGCAAGGTATGACACAACCCGGCGATTAAGTTGGCGTTTCATCACAACATATGCACCACAAAAATCGCTAGTACGCAGTGTAAACTGGCATAGTCCTATCTGCATCGACGGAGTGCATGGCAGTGAGGACCCGGTCTCATGATCCATTTGAATTTTGAACGGTAGAATATTTGGCATGCTGTAGTTCAAGATGATGGATTTCCGGTTACACTATGCCCGGATTTACAGAGGTAAATACGGGACATTGCGGATTAGTGGTGACCTCTGTAATTAAACAAGAGGATGGAGGGAGAAACCAAGTCGTCGGAAGGCGGCGACAGTACTCTTTGGATTGGGAATAACGATCGGCGGCGCACCTCCCAGGCTACGTCGAGGAATCATTAAGGTTTTTGTTGCTGGACATAACATCCTTGATGTCATGAAGTGGCTCATCTCCGGAATGTTAGTACATGGTAGTCAGACGGCGCTCACACTCGAACCGGCGGGCGATATGGTAC"
test3 = "TGGAAACAGGTCCGTTAGTCTAAGTGGGATGAGTATGTGTAGCACGATGGCGCACAAGCATAAAGTTGTTGTTCTTCTTGCTACTCAGGCCAGCATTGCTCCGACATCGTATTCTATCACGTTTCAAGCCTAAATCGTGATTTTCATAGATGCTGGCCTGATAGAGTATTTCCGAACTCCAATACAGCGGGCCACCGTTCTCGTAGTCGCTATCTCCTTTGAACAATCCCTAGGATTCGACGCTAACTCGTTGGCAATTATTTGACCCGCCCCAAATTAAACTATGCCGTGTTTCCGGAGCCCAATTTTAGTTTCTTGGGAAGGACCGATCAGAGCCCGTATTGGGGTGCCGAAAATTACTTGAATGCGGGACACCGAGGATTGGGGCTCATTTTAGCAGCTGACGAGGGACCGGGCTCGAAAGCTCACGCACGGCTTTGGGACCCCTCATTGTCGCCCTAATGTCTCACCATGTGCCCGTTATGAGGTGAAATTAAATGACCCATCTAATGGCACGTCCATTCATCTTGCCCGAATCCCATCTATAGAACCACTCATGGTTCTGCAGTTATTTAAGTACTGCCACCTCCATGAGATGGCCCTTCTTACCAACGAGGTTGCTTTAACTCGCTGAGAATGCCTGATTGGTCACTAACTCTGCGCTGTATTTTGGGTTTGCCGGCGCCTCTGTACGCCTATCTGTACACTCAAGAATCAAACTCTAGGTCGCCTATCAGCTCCACTGCCATTCATTAGCAACCAAATGTTGTGACGAAAAGAGACCTTACGTGGGACTAGCATATGAGAGCAGGTATAGGCTCTTTCCTAAT"
complement_dic = dict(zip('ACGT', 'TGCA'))

def reverse_complement(s):
    
    # Map method
    '''
    Time commplexity:
        s[::-1] is T = O(n)
        map is T = len(s) * lambda complexity of O(1) since look-up time of dictionary is O(1) = O(n)
        list is T = O(n)
        join is T = O(n)
        So T = O(4n) = O(n)
        But map is in lower order C language so it performs faster than list comprehension
    
    Space complexity:
        map makes a new generator = O(n)
        list makes a new list = O(n)
        join makes a new string = O(n)
        so O(3n) = O(n)
    '''
    # Map method
    #return "".join(list(map(lambda x: complement_dic[x], s[::-1])))
    
    # List comprehension method
    '''
    Time complexity:
        s[::-1] is O(n)
        complement_dic is O(1) for every item, so O(n) in total
        join is O(n)
        So T = O(3n)
        
    Space complexity:
        s[::-1] is O(n)
        new list is O(n)
        join makes a new string so O(n)
        so O(3n) = O(n)
    '''
    
    return "".join([ complement_dic[x] for x in s[::-1] ])

reverse_complement(test1)
reverse_complement(test2)
reverse_complement(test3)

languages = ['Java', 'Python', 'JavaScript']
versions = [14, 3, 6]



